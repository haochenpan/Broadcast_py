from collections import defaultdict, deque
from gui import Sim
from itertools import combinations
from pickle import dump, load
from time import time
import networkx as nx
import os

"""
    Configurations: specify TOTAL_NODES, MAX_FAULT_NODES, GRAPH_TYPE, and some other parameters
"""

TOTAL_NODES = 300
MAX_FAULTY_NODES = 3

VALID_GRAPH_TYPES = ['Erdos_Renyi', 'Geometric']
GRAPH_TYPE = VALID_GRAPH_TYPES[1]  # <- 1 = Geometric

# WANT_WORST_CASE_GRAPH = True  # if we want more rounds before finishing, currently not implemented
ERDOS_RENYI_EDGE_FACTOR = 18  # total num of edges = TOTAL_NODES * edge_factor
GEOMETRIC_THRESHOLD = 0.15
SAVE_PATH = os.path.join(os.getcwd(), 'bin')  # the bin folder in the current directory
NUM_OF_GRAPH_TO_GENERATE = 5  # the number of graphs needs to generates before the program exits


def propose_graph(graph_type: str):
    """
    Generates a (basic = a few hundreds of nodes) graph with exactly one connected component of the type specified
    :param graph_type: an entry in VALID_GRAPH_TYPES
    :return: a potentially desired graph, i.e. CPA is correct in this graph under the f-local fault model.
    """
    # num of tries in generating a graph, to avoid inappropriate parameters
    try_counter, max_tries = 0, 10000
    graph, ncc, src_neis = None, 0, 0  # graph, number of connected components, and number of the source's neighbors

    while ncc != 1 or src_neis != MAX_FAULTY_NODES * 2 + 1:
        try_counter += 1
        if try_counter > max_tries: raise Exception("inappropriate parameters")
        if graph_type == VALID_GRAPH_TYPES[0]:
            total_edges = TOTAL_NODES * ERDOS_RENYI_EDGE_FACTOR
            graph = nx.gnm_random_graph(TOTAL_NODES, total_edges)
        elif graph_type == VALID_GRAPH_TYPES[1]:
            graph = nx.random_geometric_graph(TOTAL_NODES, GEOMETRIC_THRESHOLD)
        else:
            raise Exception("Invalid graph type")
        ncc = nx.number_connected_components(graph)
        src_neis = len(graph.edges(0))  # the number of neighbours of the source node

    assert ncc == 1
    assert src_neis == MAX_FAULTY_NODES * 2 + 1
    return graph


def check_graph(G) -> bool:
    """
    Checks whether the graph is desired, i.e. CPA is correct in this graph under the f-local fault model,
    in synchronous network by simulating CPA (using breadth-first search) for all combinations of faulty nodes.
    Theorem II indicates that this graph is desired if and only if for all instances of simulation,
    i.e. combination of faulty nodes, all non-faulty nodes receive the fault-free source's committed value.
    :param G: a graph generated by propose_graph()
    :return: a boolean indicates whether this graph is desired
    """

    ncc = nx.number_connected_components(G)
    if ncc != 1: return False

    # TODO early termination... but the original implementation remove edges when checking a graph
    # TODO early check the worse case, i.e. all faulty nodes appear around the source

    nodes_except_src = set(range(1, TOTAL_NODES))
    desired_non_faulty_commits_count = TOTAL_NODES - MAX_FAULTY_NODES

    # for each simulation instance, we select a set of faulty nodes
    for fault_nodes in combinations(nodes_except_src, MAX_FAULTY_NODES):
        fault_nodes = set(fault_nodes)
        non_faulty_commits_count, total_rounds = broadcast(G, fault_nodes)
        if non_faulty_commits_count != desired_non_faulty_commits_count:
            return False
    return True


def broadcast(graph, faulty_nodes: set, trusted_nodes=set()):
    """
    Given a potentially desired graph and a set of faulty nodes,
    do a broadcasting to see whether all non-faulty nodes are able to receive the source's commit
    :param graph: a graph generated by propose_graph()
    :param faulty_nodes: a set of faulty nodes picked by doing combination
    :param trusted_nodes:
    :return: the number of non-faulty nodes that have committed the message, including the source
    """

    # Round 0: initialize and the source commits
    curr_round = 0
    # every non-faulty node (except the src) appears in non_faulty_commit_queue only once,
    # but all faulty nodes will not be in this queue
    non_faulty_commit_queue = deque()
    non_faulty_commit_queue.append(0)

    # to record whether a node has committed the value before (due to cyclic graph),
    # we put the node to the set if it is the source, or
    # it receives a commit from the source/trusted node, or
    # it receives (MAX_FAULT_NODES + 1) commits from incoming nodes (faulty nodes don't commit)
    non_faulty_has_committed = {0}

    # to record the number of proposes a node receives if it's not directly linked to the source
    propose_received = defaultdict(lambda: 0)

    # Round >= 1: all non-faulty nodes commits
    while len(non_faulty_commit_queue):  # while not all nodes have committed
        curr_round += 1
        for curr_node in range(len(non_faulty_commit_queue)):  # for all nodes in the current round of commits
            curr_node = non_faulty_commit_queue.popleft()
            curr_node_neis = [edge[1] for edge in graph.edges(curr_node)]  # all outgoing neighbours of the current node

            if curr_node == 0 or curr_node in trusted_nodes:  # if this commit comes from the source or trusted nodes
                for nei in curr_node_neis:
                    # If this node has committed before (due to cyclic graph) OR if this node is faulty, ignore it;
                    if nei in non_faulty_has_committed or nei in faulty_nodes:
                        continue

                    non_faulty_commit_queue.append(nei)
                    non_faulty_has_committed.add(nei)
            else:
                for nei in curr_node_neis:
                    # If this node has committed before (due to cyclic graph) OR if this node is faulty, ignore it;
                    if nei in non_faulty_has_committed or nei in faulty_nodes:
                        continue

                    # If this node is non-faulty, it commits iff it has heard (MAX_FAULT_NODES + 1) non-faulty proposes.
                    # note: faulty nodes don't propose values
                    # TODO: does MAX_FAULTY_NODES logic goes well with giant graph? yes?
                    propose_received[nei] += 1
                    if propose_received[nei] >= MAX_FAULTY_NODES + 1:
                        non_faulty_commit_queue.append(nei)
                        non_faulty_has_committed.add(nei)
    return len(non_faulty_has_committed), curr_round


def broadcast_for_gui(graph, faulty_nodes: set, trusted_nodes=set()):
    """
        To optimize the running time, separate the broadcast method to two version,
        one is for GUI (this one), and one is for validating a graph (the one in ProofByBroadcasting)
        comments to the code see the method in ProofByBroadcasting
    """

    # Round 0: the source commits
    curr_round = 0
    non_faulty_commit_queue = deque()
    non_faulty_commit_queue.append(0)
    non_faulty_has_committed = {0}
    faulty_has_committed = set()  # <- for GUI
    propose_received = defaultdict(lambda: 0)
    gui_dict = dict()  # <- for GUI
    gui_dict[curr_round] = [[0], []]  # <- for GUI

    # Round >= 1: all non-faulty nodes commits
    while len(non_faulty_commit_queue):  # while not all nodes have committed
        curr_round += 1  # for debugging and GUI directory
        curr_round_non_faulty_commits, curr_round_faulty_commits = set(), set()  # <- for GUI

        for curr_node in range(len(non_faulty_commit_queue)):
            curr_node = non_faulty_commit_queue.popleft()
            curr_node_neis = [edge[1] for edge in graph.edges(curr_node)]  # all outgoing neighbours of the current node

            if curr_node == 0 or curr_node in trusted_nodes:  # if this commit comes from the source or trusted nodes
                for nei in curr_node_neis:
                    if nei not in faulty_nodes:
                        if nei not in non_faulty_has_committed:
                            non_faulty_commit_queue.append(nei)
                            non_faulty_has_committed.add(nei)
                            curr_round_non_faulty_commits.add(nei)
                    else:
                        if nei not in faulty_has_committed:
                            faulty_has_committed.add(nei)
                            curr_round_faulty_commits.add(nei)

            else:
                for nei in curr_node_neis:
                    if nei in faulty_nodes:
                        if nei not in faulty_has_committed:
                            faulty_has_committed.add(nei)
                            curr_round_faulty_commits.add(nei)
                    else:
                        if nei not in non_faulty_has_committed:
                            # TODO: does MAX_FAULTY_NODES logic goes well with giant graph? yes?
                            propose_received[nei] += 1
                            if propose_received[nei] >= MAX_FAULTY_NODES + 1:
                                non_faulty_commit_queue.append(nei)
                                non_faulty_has_committed.add(nei)
                                curr_round_non_faulty_commits.add(nei)

        commits_list = [list(curr_round_non_faulty_commits), list(curr_round_faulty_commits)]
        if commits_list != [[], []]:
            gui_dict[curr_round] = commits_list

    # total = 0
    # for v in gui_dict.values():
    #     total += (len(v[0]) + len(v[1]))
    # assert total == len(G.nodes)
    return len(non_faulty_has_committed), gui_dict


def save_graph(G, graph_type):
    if not os.path.isdir(SAVE_PATH):
        os.mkdir(SAVE_PATH)
    if graph_type == VALID_GRAPH_TYPES[0]:
        graph_name = f'erd_{TOTAL_NODES}_{ERDOS_RENYI_EDGE_FACTOR}_{int(time())}.pi'
    elif graph_type == VALID_GRAPH_TYPES[1]:
        graph_name = f'geo_{TOTAL_NODES}_{GEOMETRIC_THRESHOLD}_{int(time())}.pi'
    else:
        graph_name = f"unk_{TOTAL_NODES}_{int(time())}"
    file_path = os.path.join(SAVE_PATH, graph_name)
    dump(G, open(file_path, 'wb'))


def generate_graph_main():
    print('***Generate a desired graph***')
    print(f"process id:{os.getpid()}")
    print(f"process configs:")
    print(f"graph type: {GRAPH_TYPE}, total nodes: {TOTAL_NODES}, max faulty nodes: {MAX_FAULTY_NODES}")
    print(f"ERDOS_RENYI_EDGE_FACTOR: {ERDOS_RENYI_EDGE_FACTOR}, GEOMETRIC_THRESHOLD: {GEOMETRIC_THRESHOLD}")

    for i in range(NUM_OF_GRAPH_TO_GENERATE):
        G = propose_graph(GRAPH_TYPE)
        while not check_graph(G):
            G = propose_graph(GRAPH_TYPE)
        save_graph(G, GRAPH_TYPE)
        print("a desired graph is generated, at", int(time()))
    print(f"process id:{os.getpid()} finished generating graph(s), exits")


def check_desired_graph_main(G):
    global TOTAL_NODES
    print("***Check whether a graph is valid***")
    TOTAL_NODES = len(G.nodes)
    print("the graph is desired") if check_graph(G) else print("not a desired graph")


# def show_gui_main(G):
#     TODO: support trusted nodes
# commits, run_dict = broadcast_for_gui(G, {11, 9, 3})
# Sim(g=G, d=run_dict)


if __name__ == '__main__':
    pass
    graph = load(open("/Users/yingjianwu/Desktop/200_0.3_erdos.p","rb"))
    _, run_dict = broadcast_for_gui(graph, [12,150,99], set([0]))
    Sim(g=graph, d=run_dict)
    # generate_graph_main()
    # g = propose_graph(GRAPH_TYPE)
    # print(len(g.nodes))
    # graph_path = '/Users/haochen/Desktop/Broadcast_py/uni_data_1500_graph.p'
    # G = load(open(graph_path, "rb"))
    # trust_nodes = {0, 300, 600, 900, 1200}
    # bad_nodes = [82, 70, 28, 305, 458, 578, 622, 764, 889, 1020, 1060, 1136, 1210, 1311, 1423]
    # bad_nodes = set(bad_nodes)
    # commits_count, run_dict = broadcast_for_gui(G, bad_nodes, trust_nodes)
    # Sim(g=G, d=run_dict)
    # check_desired_graph_main(G)
